<#
.SYNOPSIS
    Hybrid Identity Sync Status Dashboard (Full-Width + Email Report)

.DESCRIPTION
    This PowerShell script collects Azure AD Connect (Hybrid Identity Sync)
    health information such as Sync Scheduler, Last Sync details, Connector
    status, and Event summary. It then generates a styled HTML dashboard 
    and emails it inline (not as an attachment).

.NOTES
    Author      : [Your Name]
    Version     : 1.0
    Purpose     : Create visual hybrid identity sync health report and email it.
#>

param(
    [string]$OutputFile = "C:\Temp\HybridSyncDashboard_FullWidth.html"
)

# --------------------------------------------------------------
# STEP 1 ‚Äî Collect Sync Scheduler Information
# --------------------------------------------------------------
# The Get-ADSyncScheduler cmdlet retrieves current Azure AD Connect scheduler
# settings such as intervals, policy type, and staging mode.
$syncScheduler = Get-ADSyncScheduler

# --------------------------------------------------------------
# STEP 2 ‚Äî Collect Last Sync Information
# --------------------------------------------------------------
# We read the Application event log for events generated by ADSync
# that mention ‚Äúcompleted‚Äù or ‚Äúfinished‚Äù to find the latest sync.
try {
    $filter = @{ LogName = 'Application'; ProviderName = 'ADSync' }
    $lastSyncEvent = Get-WinEvent -FilterHashtable $filter -ErrorAction SilentlyContinue |
        Where-Object { $_.Message -match "completed" -or $_.Message -match "finished" } |
        Sort-Object TimeCreated -Descending | Select-Object -First 1
} catch { $lastSyncEvent = $null }

$lastSyncWhen = if ($lastSyncEvent) { $lastSyncEvent.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }

# Extract approximate duration from message (if present)
$lastSyncDuration = if ($lastSyncEvent -and $lastSyncEvent.Message -match "duration") { 
    ($lastSyncEvent.Message -split "duration")[1].Trim()
} else { "N/A" }

# Count sync errors (from last 24 hours)
try {
    $filterErr = @{ LogName = 'Application'; ProviderName = 'ADSync' }
    $lastSyncErrors = (Get-WinEvent -FilterHashtable $filterErr -ErrorAction SilentlyContinue |
        Where-Object { $_.LevelDisplayName -eq "Error" -and $_.TimeCreated -gt (Get-Date).AddDays(-1) } |
        Measure-Object).Count
} catch { $lastSyncErrors = 0 }

# --------------------------------------------------------------
# STEP 3 ‚Äî Collect Connector Information
# --------------------------------------------------------------
# We retrieve all AD Connect connectors and group them by type (AD or Entra ID)
$connectors = Get-ADSyncConnector | Select-Object Name, Type
$totalConnectors = $connectors.Count
$adConnectors = ($connectors | Where-Object { $_.Type -eq "AD" }).Count
$entraConnectors = ($connectors | Where-Object { $_.Type -match "Azure Active Directory" }).Count

# --------------------------------------------------------------
# STEP 4 ‚Äî Collect Warnings / Event Info
# --------------------------------------------------------------
# We look for provisioning errors and total event entries within the last day
$provisioningErrors = $lastSyncErrors
try {
    $filterEvt = @{ LogName = 'Application'; ProviderName = 'ADSync'; StartTime = (Get-Date).AddDays(-1) }
    $eventEntries = (Get-WinEvent -FilterHashtable $filterEvt -ErrorAction SilentlyContinue).Count
} catch { $eventEntries = 0 }

# --------------------------------------------------------------
# STEP 5 ‚Äî Build HTML Structure (Header, Cards, Tables)
# --------------------------------------------------------------
# CSS styling: consistent layout, blue accent, responsive design
$head = @"
<style>
body {
    font-family: 'Segoe UI', Arial, sans-serif;
    background-color: #f5f7fb;
    margin: 0;
    padding: 0;
}
.dashboard { max-width: 95%; margin: 20px auto; }
.header {
    text-align: center; background-color: #fff; padding: 22px;
    border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 25px;
}
.header h1 { color: #0078d7; margin-bottom: 12px; font-size: 28px; }
.header p { font-size: 14px; color: #333; line-height: 1.6; }
.cards {
    display: flex; flex-wrap: nowrap; justify-content: space-between; gap: 20px;
}
.card {
    flex: 1; background-color: #fff; border-left: 5px solid #0078d7;
    border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    padding: 15px 18px; font-size: 14px;
}
.card h2 { color: #0078d7; font-size: 18px; margin-bottom: 10px; }
.card table { width: 100%; border-collapse: collapse; margin-top: 6px; }
.card th, .card td { text-align: left; padding: 6px 4px; border-bottom: 1px solid #eaeaea; }
@media screen and (max-width: 1000px) {
    .cards { flex-wrap: wrap; } .card { min-width: 48%; margin-bottom: 10px; }
}
@media screen and (max-width: 700px) { .card { min-width: 100%; } }
</style>
"@

# Main dashboard layout (HTML)
$body = @"
<div class='dashboard'>
    <div class='header'>
        <h1>Hybrid Identity Sync Status Dashboard</h1>
        <p><b>Tenant:</b> contoso.onmicrosoft.com | <b>Primary:</b> MDC-ADC | <b>Staging:</b> ATL-ADC<br>
        <b>Last Sync:</b> $lastSyncWhen | <b>Next Sync:</b> $($syncScheduler.NextSyncCycleStartTimeInUTC) | 
        <b>Interval:</b> $($syncScheduler.CurrentlyEffectiveSyncCycleInterval)<br>
        <b>Scheduler:</b> <span style='color:red;'>Idle</span> | 
        <b>Provisioning Errors:</b> $provisioningErrors</p>
    </div>

    <div class='cards'>

        <!-- Sync Scheduler -->
        <div class='card'>
            <h2>Sync Scheduler</h2>
            <table>
                <tr><th>Allowed Sync Cycle Interval</th><td>$($syncScheduler.AllowedSyncCycleInterval)</td></tr>
                <tr><th>Currently Effective Sync Cycle Interval</th><td>$($syncScheduler.CurrentlyEffectiveSyncCycleInterval)</td></tr>
                <tr><th>Customized Sync Cycle Interval</th><td>$($syncScheduler.CustomizedSyncCycleInterval)</td></tr>
                <tr><th>Next Sync Cycle Policy Type</th><td>$($syncScheduler.NextSyncCyclePolicyType)</td></tr>
                <tr><th>Next Sync Cycle Start Time (UTC)</th><td>$($syncScheduler.NextSyncCycleStartTimeInUTC)</td></tr>
                <tr><th>Purge Run History Interval</th><td>$($syncScheduler.PurgeRunHistoryInterval)</td></tr>
                <tr><th>Sync Cycle In Progress</th><td>$($syncScheduler.SyncCycleInProgress)</td></tr>
                <tr><th>Maintenance Cycle In Progress</th><td>$($syncScheduler.MaintenanceCycleInProgress)</td></tr>
                <tr><th>Staging Mode Enabled</th><td>$($syncScheduler.StagingModeEnabled)</td></tr>
            </table>
        </div>

        <!-- Last Sync Info -->
        <div class='card'>
            <h2>Last Sync</h2>
            <p><b>When:</b> $lastSyncWhen</p>
            <p><b>Duration:</b> $lastSyncDuration</p>
            <p><b>Errors:</b> $lastSyncErrors</p>
        </div>

        <!-- Connector Summary -->
        <div class='card'>
            <h2>Connectors</h2>
            <p><b>Total:</b> $totalConnectors</p>
            <p><b>AD:</b> $adConnectors</p>
            <p><b>Entra:</b> $entraConnectors</p>
            <table><tr><th>Name</th><th>Type</th></tr>
"@

foreach ($c in $connectors) {
    $body += "<tr><td>$($c.Name)</td><td>$($c.Type)</td></tr>"
}

$body += @"
            </table>
        </div>

        <!-- Warnings / Event Summary -->
        <div class='card'>
            <h2>Warnings</h2>
            <p><b>Provisioning Errors:</b> $provisioningErrors</p>
            <p><b>Event Entries:</b> $eventEntries</p>
        </div>
    </div>
</div>
"@

# Write HTML file locally
ConvertTo-Html -Head $head -Body $body -Title "Hybrid Identity Sync Status Dashboard" |
    Out-File -FilePath $OutputFile -Encoding UTF8

Write-Host "‚úÖ Dashboard generated successfully: $OutputFile"

# --------------------------------------------------------------
# STEP 6 ‚Äî Send the Dashboard via Email (Inline HTML)
# --------------------------------------------------------------
# Email details: uses internal SMTP relay, no authentication
$SubDate     = (Get-Date).ToString('MMMM-dd')
$subject     = "Hybrid Identity Sync Dashboard - " + $SubDate
$priority    = "Normal"
$smtpServer  = "SMTP Address"
$emailFrom   = "contoso.microsoft.com"
$emailTo     = "contoso.employee.microsoft.com"
$port        = 25

# Read HTML content and send inline
$bodyHtml = Get-Content -Path $OutputFile -Raw

Send-MailMessage -From $emailFrom -To $emailTo -Subject $subject `
    -Body $bodyHtml -BodyAsHtml `
    -SmtpServer $smtpServer -Port $port -Priority $priority

Write-Host "üìß Email sent successfully to $emailTo using $smtpServer"
